def func_decorator(func):
    def wrapper():
        print('-------------действия перед вызовом функции------------')
        func()
        print('-------------действия после вызовом функции------------')

    return wrapper


def some_func():
    print('Вызов функции some_func')


"Можно вызвать функцию таким образом:"

some_func()  # Вызов функции some_func

"А можно при помощи func_decorator (декоратора)"
f = func_decorator(some_func)  # f - ссылка на функцию wrapper, в аргументе ссылка на функцию some_func()
f()  # ---------действия перед вызовом функции----Вызов функции some_func----действия после вызовом функции------------
"Т.е. мы не только вызвали функцию some_func, но что-то сделали до и после"

"""ПРИНЦИП РАБОТЫ: у нас есть глобальная переменная f в глобальной области видимости, которая ссылается на внутреннюю 
функцию wrapper, определенная во внешней функции func_decorator, а параметр func ссылается на функцию some_func. 
Т.е. когда мы вызываем функцию f, то вызывается wrapper, а та вызывает some_func и дополнительно что-то делает перед ее
 вызовом и после. Делается это для расширения функционала."""

some_func = func_decorator(some_func)  # Обычно создается ссылка на тоже самое имя. В итоге функция some_func
# меняет свою работу

some_func()

"""Если в функции some_func будут изначально присутствовать аргументы, то в функцию wrapper их тоже нужно добавить.
 Лучше всего добавить *args, **kwargs
 
 Кроме того, если функция some_func будет что-то возвращать, то у нас ничего не будет возвращено в итоге, т.к. функция
 wrapper ничего не возвращает. Поэтому это можно добавить."""

print('\n\nВ ИТОГЕ получаем универсальный декоратор для любых функций\n\n')


def func_decorator2(func2):
    def wrapper2(*args, **kwargs):
        print('-------------действия перед вызовом функции------------')
        res = func2(*args, **kwargs)
        print('-------------действия после вызовом функции------------')
        return res

    return wrapper2


def some_func2(title, tag):
    print(f'Вызов функции some_func2. Tittle = {title}, tag = {tag}')
    return 'return'


f2 = func_decorator2(some_func2)
res = f2('tit;e', 't@g')
print(res)

"""Вариант применения - засечь время работы функции."""

print("\n\nОбычно декорируют следующим образом, при помощи @\n\n")


@func_decorator2
def some_func3(title, tag):
    print(f'Вызов функции some_func2. Tittle = {title}, tag = {tag}')
    return 'return'


some_func3('1', '2')

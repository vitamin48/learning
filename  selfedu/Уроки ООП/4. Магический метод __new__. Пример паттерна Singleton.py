"""
__new__ — это специальный метод (магический метод) в Python, который отвечает за создание нового экземпляра класса
перед его инициализацией методом __init__

Магический метод __new__ вызывается перед созданием объекта класса, в то время как __init__ - после
"""


class Point:
    def __new__(cls, *args, **kwargs):
        print('вызов __new__ для ' + str(cls))

    def __init__(self, x=0, y=0):
        print('вызов __init__ для ' + str(self))
        self.x = x
        self.y = y


""""Экземпляр класса фактически не был создан (удивительно, да?), т.к. метод __new__ выполнился, а __init__ нет,
а значит, ссылка это None. Это из-за того, что магический метод __new__ возвращает ссылку на объект, а в нашем случае
он вызван явно и ничего не возвращает.
"""
pt = Point(1, 2)  # вызов __new__ для <class '__main__.Point'>
print(pt)  # None

"""Создадим другой класс и пропишем явно возврат ссылки на объект класса. Теперь при создании экземпляра будет
вызван __init__"""


class Point2:
    def __new__(cls, *args, **kwargs):
        print('вызов __new__ для ' + str(cls))
        return super().__new__(cls)  # super() - это ссылка на базовый класс, из которого вызываем __new__ и передаем
        # ссылку на текущий класс Point (cls)

    def __init__(self, x=0, y=0):
        print('вызов __init__ для ' + str(self))
        self.x = x
        self.y = y


pt2 = Point2(1, 2)  # вызов __new__ для <class '__main__.Point2'>\n вызов __init__ для
# <__main__.Point2 object at 0x00000229C43C25C0>
print(pt2)  # <__main__.Point2 object at 0x00000229C43C25C0>

"""Паттерн Singleton. Можно создавать только 1 экземпляр класса.
Например, в случае работы с БД"""


class DataBase:
    __instance = None  # Так обозначим ссылку на экземпляр класса, чтобы понимать, существует ли экземпляр класса

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None:
            # если __instance == None, то присвоим ему адрес нового созданного объекта
            cls.__instance = super().__new__(cls)
        # Таким образом, если объект существует, то мы вернем ссылку на него, а если нет - то присвоим.
        # Это поможет понимать, существует ли экземпляр класса или нет
        return cls.__instance

    def __del__(self):
        # Если объект будет удален сборщиком мусора, то вернем значение (флаг) в исходное значение None.
        # После этого можно повторно создать экземпляр этого класса.
        DataBase.__instance = None

    def __init__(self, user, psw, port):
        self.user = user
        self.psw = psw
        self.port = port

    def connect(self):
        print(f'соединение с БД: {self.user}, {self.psw}, {self.port}')

    def close(self):
        print('Закрытие соединения с БД')

    def read(self):
        return 'данные из БД'

    def write(self, data):
        print(f'запись в БД {data}')


"""При попытке создания нескольких экземпляров класса DataBase ошибки не будет, но все экземпляры будут иметь один и 
тот же id, т.е. будут ссылаться на один и тот же объект"""
db = DataBase('root', '1234', 80)
db2 = DataBase('user', '4321', 40)
print(id(db))  # 2462061476592
print(id(db2))  # 2462061476592

"""У данной реализации есть недостаток. При попытке создания нового экземпляра класса db2 будут изменены передаваемые 
параметры в __init__. Исправить это можно другим магическим методом __call__"""
db.connect()  # соединение с БД: user, 4321, 40 <--- хотя были указаны изначально другие параметры ('root', '1234', 80)
db2.connect()  # соединение с БД: user, 4321, 40

"""
Пример: Наследование от str (неизменяемый тип)
Если мы наследуемся от str, метод __init__ не поможет, потому что str — неизменяемый тип. В таких случаях __new__ 
позволяет задать значение при создании объекта.
"""


class MyString(str):
    def __new__(cls, value):
        print("Создаём строку:", value)
        return super().__new__(cls, value.upper())  # Делаем строку заглавной


s = MyString("hello")
print(s)  # HELLO

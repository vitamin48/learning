"""
Магические методы или dunder-методы (от анг. double underscope)
Магический метод __call__ служит для вызова класса c = Counter() - речь про скобки, т.е. возможность вызова
"""
import math


class Counter:
    def __init__(self):
        self.__counter = 0


c = Counter()  # Скобки в общем случае это оператор вызова функции, а в данном случае класса
"""
Сначала вызывается __call__, затем __new__, __init__ 
"""
# с() - будет ошибка, потому как экземпляры класса вызывать через оператора вызова функции (__call__) не можем, т.к.
# в классе Counter магический метод __call__ не вызван явно

"Вызовем __call__ явно"


class Counter2:
    def __init__(self):
        self.__counter = 0

    def __call__(self, *args, **kwargs):
        print('__call__')
        self.__counter += 1
        return self.__counter


# теперь можно вызвать (речь о скобках) из оператора вызова функции (__call__)
c2 = Counter2()
c2()  # __call__ (ошибки нет, т.к. в классе Counter2 магический метод __call__ задан явно
"""Если экземпляры класса можно вызывать подобно функциям, то этот класс называется ФУНКТОРОМ"""
c2()
c2()
res = c2()
print(res)  # 4 (т.е. при каждом вызове срабатывает метод __call__, выводится print и каждый раз увеличивается счетчик
"Можно создать несколько независимых счетчиков"
c3 = Counter2()
res3 = c3()
print(res3)  # 1


class StripChars:
    """Функторы могут использоваться как альтернатива замыканиям"""

    def __init__(self, chars):
        self.__chars = chars

    def __call__(self, *args, **kwargs):
        if not isinstance(args[0], str):
            raise TypeError('Аргумент должен быть строкой')
        return args[0].strip(self.__chars)


s1 = StripChars('&?:!.;')
print(s1('Hi!!?'))  # Hi
s2 = StripChars(' ')
print(s2(' hello    '))  # hello


class Derivate:
    """Функторы могут использоваться для создания декораторов на основе класса"""

    def __init__(self, func):
        """При создании объекта класса Derivate в конструктор передается функция func.
            Эта функция сохраняется в приватный атрибут self.__fn."""
        self.__fn = func

    def __call__(self, x, y=2, *args, **kwargs):
        result = self.__fn(x + y)
        return result


"""Декоратор @Derivate применяется к функции df_. Это означает, что функция df_ будет заменена объектом класса Derivate,
 который "оборачивает" исходную функцию.
 
Когда декоратор @Derivate применяется к функции df_, происходит следующее:
Создается объект класса Derivate, и в конструктор передается функция df_.
Исходная функция df_ заменяется этим объектом.
Теперь df_ — это не функция, а объект класса Derivate, который можно вызывать как функцию благодаря методу __call__."""


@Derivate
def df_(x):
    return x + 8


"""
Когда вы вызываете df_(3), происходит следующее:
Объект df_ (который является экземпляром класса Derivate) вызывается как функция.
Вызывается метод __call__ класса Derivate, и ему передается аргумент x=3.

Внутри метода __call__:
Значение x + y вычисляется как 3 + 2 (поскольку y по умолчанию равно 2).
Исходная функция self.__fn (которая является функцией df_) вызывается с аргументом 5 (результат 3 + 2).
Исходная функция df_ возвращает 5 + 8 = 13.
Метод __call__ возвращает результат 13.
"""
print(df_(3))  # 13

"""
Декораторы на основе классов удобны, когда:
Нужно сохранить состояние между вызовами (например, кэш или счётчик).
Требуется сложная логика, которую проще реализовать в классе.
Нужно повторно использовать или расширять декоратор.
"""

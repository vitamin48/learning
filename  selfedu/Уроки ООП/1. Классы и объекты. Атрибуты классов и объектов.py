class Point:
    "Класс для представления координат точек на плоскости"
    color = 'red'  # переменные внутри класса - это его атрибуты или свойства
    circle = 2


a = Point()  # создание экземпляра класса
print(a.color)  # red
b = Point()  # второй экземпляр класса (a и b независимые объекты)
print(type(a))  # <class '__main__.Point'>
print(a.__dict__)  # {}, т.к. сам объект a не содержит никаких свойств, а лишь ссылается на свойства из класса

"Если изменить свойство цвета, то он изменится для экземпляра a, но не изменится для b"
a.color = 'green'
print(a.color)  # green
print(b.color)  # red

"После того, как мы изменили цвет для экз. a, у него появился свой атрибут в пространстве имен"
print(a.__dict__)  # {'color': 'green'}, а раньше было {} (см. выше)

"Можно динамически добавлять свойство в класс. После этого во всех ранее созданных экземплярах появится это свойство"
Point.type_pt = 'disc'
print(a.type_pt)  # disc
# Аналог
setattr(Point, 'prop', 1)
setattr(Point, 'type_pt', 'square')  # изменение значения атрибута в классе
print(a.type_pt)  # square
print(a.prop)  # 1

"Значения свойств класс можно добавлять в переменную"
res = b.color
print(res)  # red
# В случае, если атрибута нет (например, b.abc), то возникнет ошибка. Чтобы в таком случае избежать ошибку,
# используется getattr()
print(getattr(a, 'abc', False))  # False

"Удаление свойств класса"
del Point.prop  # в случае отсутствия свойства prop, возникнет ошибка
# Поэтому желательно проверить наличие свойства перед удалением
print(hasattr(Point, 'prop'))  # False (т.к. было удаление выше)
# Аналог delattr(Point, 'prop')

"Если из экземпляра класса удалить свойство, то оно не удалится полностью, а будет ссылаться на это свойство из класса"
b.color = 'black'
print(b.color)  # black
del b.color
print(b.color)  # red (как в свойстве класса изначально)

"Динамическое присвоение локальных свойств класса"
a.x = 1
a.y = 2
b.x = 10
b.y = 20

"Описание класса"
print(Point.__doc__)  # Класс для представления координат точек на плоскости

## Хэш можно применять только для неизменяемых объектов. 
Если объект **изменяемый** (например, список или словарь), он **не может** быть хешируемым (`unhashable type`).
Если объекты `a==b` (равны), то равен и их хэш. Равные хэши: `hash(a) == hash(b)` не гарантируют равенство объектов.  
Если хэши не равны: `hash(a)!=hash(b)`, то объекты точно не равны.  
  
```python
print(hash(123))  # 123  
print(hash('Python'))  # -5546154524688776929 (каждый раз разные)  
print(hash((1, 2, 3)))  # 529344067295497451 (каждый раз разные)  
```
  
> Наглядный пример использования хэша - это вычисление хэша ключа в словаре, что позволяет использовать быстрый поиск этого ключа. Вычисление происходит автоматически при создании словаря. Словарь хранит коллекцию: (хэш ключа, ключ)
   ## Для экземпляров класса `Point` `p1` и `p2` хэши будут разными, не смотря на то, что значения `x` и `y` одинаковы. 
```python
class Point:  
    def __init__(self, x, y):  
        self.x = x  
        self.y = y  


p1 = Point(1, 2)  
p2 = Point(1, 2)  
  
print(hash(p1))  # 184039199976  
print(hash(p2))  # 184039200354  
  
print(p1 == p2)  # False, но, если будет явно задан магический метод __eq__ как в классе Point2, то будет True.  
```
  
  #### При этом хэш вычисляться не будет, если не задать его явно магическим методом __hash__  
    
```python
class Point2:  
    def __init__(self, x, y):  
        self.x = x  
        self.y = y  
  
    def __eq__(self, other):  
        """Объекты с одинаковыми координатами будут равны"""  
        return self.x == other.x and self.y == other.y  
  
    def __hash__(self):  
        return hash((self.x, self.y))  
```
>   Если переопределить `__eq__`, то `__hash__` автоматически становится `None` (если не переопределён явно).
  
Для экземпляров класса `Point2` `p3` и `p4` хэши будут одинаковыми, т.к. явно задан (переопределен) магический метод   `__hash__`   
```python
p3 = Point2(3, 4)  
p4 = Point2(3, 4)  
print(hash(p3))  # 1079245023883434373  
print(hash(p4))  # 1079245023883434373  
```
  
Всё это дает тонкую настройку поведения объектов. Например, при создании словаря, где ключ - это экземпляр класса, будет только 1 ключ и 1 значение, т.к. `p3` и `p4` воспринимаются как один и тот же ключ, т.к. их хэши равны 
```python
d = {}  
d[p3] = 1  
d[p4] = 2  
print(d)  # {<__main__.Point2 object at 0x000001C0D55ABE20>: 2}  
```
При этом для класса Point будет 2 ключа и 2 значения, т.к. хэши будут разными 
```python
d2 = {}  
d2[p1] = 1  
d2[p2] = 2  
print(d2)  # {<__main__.Point object at 0x00000139581DBFD0>: 1, <__main__.Point object at 0x00000139581DBE80>: 2}
```
> По умолчанию `hash()` для пользовательских классов возвращает `id()` (если `__hash__` не переопределён).

#### Когда переопределять `__hash__`?

- Если класс логически **неизменяемый** и используется как ключ в словаре или элемент множества.
    
- Если нужно, чтобы объекты с одинаковыми атрибутами считались одинаковыми (как `Point2`)
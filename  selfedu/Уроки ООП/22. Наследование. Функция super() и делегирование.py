class Geom:
    name = 'Geom'

    def __init__(self, x1, y1, x2, y2):
        print(f'__init__ Geom для класса: {self.__class__}')
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2


class Line(Geom):
    name = 'Line'  # Переопределение (overriding), если атрибут есть в базовом классе
    """Здесь дублирование кода, поэтому часть кода из __init__ перенесем в базовый класс Geom"""

    # def __init__(self, x1, y1, x2, y2):
    #     self.x1 = x1
    #     self.y1 = y1
    #     self.x2 = x2
    #     self.y2 = y2

    def draw(self):  # Рсширение (extended), если атрибута нет в базовом классе
        print('Рисование линии')


class Rect(Geom):
    """Здесь дублирование кода, поэтому часть кода из __init__ перенесем в базовый класс Geom"""

    def __init__(self, x1, y1, x2, y2, fill=None):
        # self.x1 = x1
        # self.y1 = y1
        # self.x2 = x2
        # self.y2 = y2
        print('Инициализатор Rect')
        self.fill = fill

    def draw(self):  # Рсширение (extended), если атрибута нет в базовом классе
        print('Рисование прямоугольника')


l = Line(0, 0, 10, 20)

"""
Цепочка вызова:
l = Line()
->
__call__(self, *args, **kwargs):
obj = self.__new__(self, *args, **kwargs)
self.__init__(obj, *args, **kwargs)
return obj

Метод __call__ берется из метакласса
"""

r = Rect(1, 2, 3, 4)  # Инициализатор Rect, т.е. Инициализатор из базового класса Geom не был вызван,


# т.к. он переопределен в Rect. В этом случае не будут определены переменные x1, y1, x2, y2, чтобы это исправить, нужно
# воспользоваться классом super

class Rect2(Geom):
    """Здесь дублирование кода, поэтому часть кода из __init__ перенесем в базовый класс Geom"""

    def __init__(self, x1, y1, x2, y2, fill=None):
        """Функция super() для обращения к базовому классу, она возвращает ссылку на объект-посредник, через который
        происходит вызов базового класса. Вызов метода из базового класса называется ДЕЛИГИРОВАНИЕМ"""
        super().__init__(x1, y1, x2, y2)  # следует вызывать в первую очередь, т.к. дублирующиеся параметры могут быть
        # изменены и в итоге будет оставлен последний вариант
        print('Инициализатор Rect2')
        self.fill = fill

    def draw(self):  # Расширение (extended), если атрибута нет в базовом классе
        print('Рисование прямоугольника2')


r2 = Rect2(5, 6, 7, 8)
print(r2.__dict__)  # {'x1': 5, 'y1': 6, 'x2': 7, 'y2': 8, 'fill': None} (всё сформировано корректно)
